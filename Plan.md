# План реализации проекта «Морской бой» (TCP, многопоточно)

## 0) Разделение ролей и общий рабочий процесс

Команда из 2 человек:

Разработчик сервера — отвечает за серверную часть, маршрутизацию, комнаты, матчмейкинг, синхронизацию.

Разработчик клиента — отвечает за UI в консоли, ввод игроков, отправку/приём сообщений, отображение доски.

На старте согласовать протокол (см. шаг 2). Пока протокол не зафиксирован — реализация бессмысленна.

Итеративная разработка: сначала «минимальный рабочий протокол» (connect/list), потом матчмейкинг, затем игровая логика.

## 1) Технические требования / ограничения

Протокол — TCP (на основе ObjectInputStream/ObjectOutputStream и сериализуемых Message).

Многопоточность: сервер должен обслуживать нескольких клиентов одновременно (каждый клиент — отдельный ServerThread), а каждый матч — управляться из отдельного объекта/потока GameSession.

Клиент — консольное приложение (в будущем можно сделать GUI).

Поддержка отсоединения и таймаутов.

Логирование на сервере (для отладки).

## 2) Проектирование протокола (обязательный шаг — согласовать с напарником)

Основная идея: сериализуемые Message-классы (как в примере). Каждое сообщение имеет id (команда) и поля. Раздели коммуникацию на стадии:

A. Сессия/регистрация

MessageConnect(userNic, userFullName) — клиент регистрируется.

MessageConnectResult(ok|error, message) — ответ сервера.

B. Список пользователей / запрос на игру

MessageUser — запрос списка свободных/онлайн пользователей.

MessageUserResult(String[] userNics) — ответ со списком.

MessageChallenge(fromNic, toNic) — игрок A предлагает игроку B сыграть.

MessageChallengeResult(challengeId, ok|error, message) — ответ сервера на отправку (например, "отправлено"/"не найден игрок").

MessageChallengeRequest(fromNic) — сервер пересылает B уведомление о вызове.

MessageChallengeResponse(fromNic, accept:boolean) — B отвечает (accept/decline).

MessageChallengeFinal(result, sessionId) — сервер сообщает A об ответе B и даёт sessionId при согласии.

C. Игровая логика (внутри игровой сессии)

MessageGameStart(sessionId, opponentNic, yourTurn:boolean) — сервер сообщает начало матча и кто ходит.

MessagePlaceShips(sessionId, ShipPlacementData) — (опционально) можно позволить клиенту отправить расстановку или сервер принять заранее согласованные расстановки.

MessageMove(sessionId, x, y) — игрок делает ход.

MessageMoveResult(sessionId, x, y, hit:boolean, sunk:boolean, gameOver:boolean) — сервер пересылает результат хода обеим сторонам.

MessageGameOver(sessionId, winnerNic) — объявление победителя.

MessageForfeit(sessionId, nic) — игрок сдался.

D. Обычные функции

MessagePing / MessagePong — keepalive.

MessageDisconnect — разрыв соединения.

MessageError(code, text) — общие ошибки.

Протокол должен включать:

однозначные id (как у тебя CMD_...),

чёткие поля в сообщениях,

коды результата (OK, ERROR) и человеческие тексты.

Согласуйте детали (названия сообщений и поля) до реализации.

## 3) Сервер: архитектура и ключевые компоненты

Основные компоненты:

ServerMain — слушает ServerSocket, принимает подключения, создаёт ServerThread.

ServerThread — per-client поток:

хранит ObjectInputStream/ObjectOutputStream;

рассылает/принимает Message;

регистрирует пользователя в глобальном реестре;

пересылает вызовы/ходы в нужные GameSession.

UserRegistry (в существующем коде — ServerMain.users) — потокобезопасная карта nic -> ServerThread.

GameSession — класс, представляющий пару игроков и игровой цикл:

содержит поле sessionId, playerA и playerB (можно хранить userNic);

игровое поле для каждого игрока (матрицы 10x10), состояние (ships positions, hits);

очередь ходов и проверка правил (правильность размещения кораблей, проверка попаданий/затоплений);

синхронизация: только один ход в момент времени; сервер валидирует ход и отправляет MoveResult.

MatchMaker — логика связывания игроков: принимает Challenge и инициирует GameSession при согласии.

Потокобезопасность:

Любой доступ к users и sessions — синхронизировать (использовать synchronized, ConcurrentHashMap).

GameSession внутренне синхронизирует состояния (используй synchronized или ReentrantLock).

Обработчики сообщений в ServerThread не должны блокировать главный цикл; отправку сообщений в другие потоки делайте неблокирующей или через очереди.

## 4) Клиент: архитектура и UX

Основные функции клиента:

Подключение: MessageConnect.

Получение списка игроков: команда users.

Отправка вызова: challenge 'nic'.

Ожидание ответа: блокирование в консоли на время, либо асинхронное уведомление.

В случае согласия: запуск игрового режима — отображение своей доски и доски противника (скрытой), ввод координат для хода.

Получение результатов (hit/miss/sunk) и обновление отображения.

Обработка тайм-аута/потери соединения.

UI:

Консольное меню: users, challenge 'nic', accept/decline при приходе запроса, place для расстановки кораблей, move x y, forfeit, quit.

Подсказки и формат вывода (локализовать, если нужно).

## 5) Реализация игровых правил (серверная сторона)

Поле 10×10, набор кораблей (1×4, 2×3, 3×2, 4×1) — согласуйте.

Сервер должен проверять корректность расстановки (корабли не пересекаются, в пределах поля).

Ход: проверять границы и что клетка не билась ранее.

Если hit — пометить, проверить sunk (все клетки корабля поражены).

Проверка gameOver — все корабли оппонента уничтожены.

При каждом шаге сервер генерирует MessageMoveResult и отправляет обоим игрокам.

## 6) Сообщения между компонентами (последовательности)

Пример сценария (A вызывает B, игра начинается):

A MessageConnect → сервер → MessageConnectResult(OK)

B MessageConnect → сервер

A -> MessageUser → получает список

A -> MessageChallenge(from=A,to=B) → сервер

Сервер → B MessageChallengeRequest(from=A)

B (в консоли) видит вызов и шлёт → MessageChallengeResponse(from=B, accept=true/false)

Сервер получает ответ:

если accept=false → уведомляет A (MessageChallengeFinal(result=declined))

если accept=true → создаёт sessionId, создаёт GameSession, уведомляет обоих: MessageGameStart(sessionId, opponent, yourTurn)

Игроки присылают MessagePlaceShips(sessionId, placement) (или сервер использует заранее присланные при подключении).

Игрок, у которого yourTurn=true, отправляет MessageMove(sessionId,x,y).

Сервер валидирует ход, обновляет поля и рассылает MessageMoveResult обеим сторонам (с флагами hit/sunk/gameOver).

Повторять до gameOver. Затем MessageGameOver.

## 7) Обработка ошибок, таймауты и отсоединения

Сервер: при SocketException или таймауте нужно пометить клиента как оффлайн и по возможности уведомить оппонента о победе (forfeit).

Таймаут хода (опция): если игрок не ходит N секунд — засчитывать поражение.

Коррупция сообщений: проверять типы при десериализации; использовать MessageResult с кодом ошибки.

Логирование: на сервере логировать все ключевые события (connect/disconnect/challenge/move/error).

## 8) Тестирование и отладка (пошагово)

Тест протокола без игры

Сделать простые клиенты, которые только connect и users. Проверить регистрация/список пользователей.

Тест вызова (challenge)

A посылает Challenge, B получает, B отвечает, сервер корректно маршрутизует.

Тест создания GameSession

На сервере создать dummy GameSession, отправлять GameStart клиентам.

Тест ходов

Симулировать ходы вручную, проверять MoveResult и синхронизацию.

Тест отказа/отключения

Один клиент уходит во время игры — проверить очистку GameSession.

Нагрузочное тестирование

Подключить много клиентов (скрипт или loop), проверить, что сервер не падает.

Интеграционные тесты

Запустить сервер и два клиента, пройти полную игру.

## 9) Пошаговый план работ (milestones)

М1 (протокол + skeleton) — 1–2 дня

Фиксировать все Message-типы и поля.

Реализовать базовые Message-классы.

Сделать ServerMain + ServerThread (register users, list users).

Сделать ClientMain с командами connect и users.

M2 (matchmaking) — 1–2 дня

Реализовать Challenge/ChallengeRequest/ChallengeResponse.

Реализовать MatchMaker / создание GameSession.

M3 (игровая логика) — 2–3 дня

Реализовать GameSession с проверкой размещения кораблей и ходов.

Сообщения Move / MoveResult.

Завершение игры, уведомления.

M4 (отказоустойчивость и таймауты) — 1–2 дня

Обработка отключений, таймауты ходов, forfeit.

Логирование.

M5 (тестирование и полировка) — 1–2 дня

Интеграционные тесты, документация протокола, инструкции запуска.

## 10) Рекомендации по реализации / хорошие практики

Не блокируй главный поток сервера; каждый ServerThread работает независимо.

Для обмена сообщение→сервер→игроку используй synchronized или ConcurrentLinkedQueue для очереди исходящих сообщений.

В GameSession держи строгую состояниевую машину: WAITING_FOR_PLACEMENT, IN_PROGRESS, FINISHED.

Валидируй все входящие данные на сервере (не доверяй клиенту).

Логируй с уровнями (INFO/DEBUG/ERROR).

Документируй все Message поля — сделай README/протокол в отдельном файле.

Используй serialVersionUID в Message классах.

Для тестирования используй 2 окна терминала (две копии клиента) + один сервер.

## 11) Пример контролируемых сценариев (для тестов)

Успешная игра: A вызывает B → B принимает → расстановка → игра → победа A.

Отказ в вызове: A вызывает B → B отклоняет → A получает уведомление.

Сбой клиента: B отключается во время игры → A автоматически побеждает.

Неверный ход: клиент посылает некорректные координаты → сервер возвращает MessageError.

## 12) Документация и сдача

Подготовьте README с описанием протокола (список сообщений и полей), команд для клиента, инструкции запуска сервера и клиентов.

Приложите скриншот / лог одной полной игры.

Убедитесь, что код содержит комментарии и что serialVersionUID проставлен.
